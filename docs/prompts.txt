"Revisa a fondo el proyecto Django proporcionado, que corresponde a un simulador bancario web  con las siguientes caracterÃ­sticas clave: 

    El sistema permite que los clientes ingresen mediante autenticaciÃ³n por usuario y contraseÃ±a , validando credenciales y generando un token de sesiÃ³n seguro .
    Antes de realizar transferencias, se implementa un challenge de OTP (One-Time Password)  como capa adicional de seguridad.
    Una vez confirmada la transferencia, se ejecuta el proceso correspondiente y se devuelve una respuesta clara al cliente o API consumidora.
    Incluye un dashboard administrativo  desde el cual se pueden crear y gestionar clientes, acreedores, transacciones y otros datos esenciales del sistema.
    Debe recibir transferencias entrantes desde backends externos (por ejemplo, por Internet), procesÃ¡ndolas correctamente segÃºn lÃ³gica bancaria simulada.
    Utiliza SQLite  como base de datos principal.
    No utiliza REST Framework ni APIs RESTful; todo el frontend estÃ¡ construido con HTML y plantillas Django  de buen diseÃ±o, siguiendo estÃ¡ndares actuales de usabilidad y experiencia de usuario.
        

Para comprender mejor la estructura y comportamiento esperado de ciertas funcionalidades, toma como referencia los archivos JSON ubicados en la carpeta docs/swagger , los cuales describen esquemas y flujos lÃ³gicos similares a los que deberÃ­a seguir el sistema. 

Tu labor consiste en: 

    Analizar exhaustivamente  el cÃ³digo actual: 
        Verificar estructura del proyecto (aplicaciones, directorios, archivos).
        Evaluar modelos de datos, vistas, formularios, URLs, templates, settings y seguridad.
        Identificar errores, bugs, cÃ³digo redundante, malas prÃ¡cticas, posibles vulnerabilidades de seguridad y puntos de mejora.
        Comparar la implementaciÃ³n actual con los esquemas definidos en los archivos de docs/swagger para validar coherencia.
            

    Refactorizar completamente  el proyecto para dejarlo totalmente funcional, seguro, bien organizado y escalable, aplicando lo siguiente: 
        ImplementaciÃ³n correcta de autenticaciÃ³n y manejo de sesiones seguras.
        GeneraciÃ³n, envÃ­o y verificaciÃ³n de tokens OTP (pueden ser simulados si no hay integraciÃ³n real con SMS/email).
        LÃ³gica clara y segura para validar y procesar transferencias.
        Dashboard intuitivo y seguro para la gestiÃ³n de usuarios, acreedores y transacciones.
        RecepciÃ³n y procesamiento adecuado de transferencias entrantes desde sistemas externos (simuladas o reales).
        DiseÃ±o limpio y moderno en las plantillas HTML, usando estÃ¡ndares actuales de UX/UI (sin frameworks frontend como React, solo HTML, CSS y JS bÃ¡sico si aplica).
        Cumplimiento de buenas prÃ¡cticas de seguridad: protecciÃ³n contra CSRF, XSS, inyecciones SQL, configuraciÃ³n segura de settings.py, etc.
        Manejo correcto de errores, logs y mensajes de usuario claros.
            

    Realizar pruebas internas completas  de todas las funcionalidades antes de entregar el proyecto corregido: 
        Pruebas manuales o automatizadas de inicio de sesiÃ³n, autenticaciÃ³n multifactor (OTP), creaciÃ³n de clientes, transferencias, recepciÃ³n de transacciones, etc.
        ValidaciÃ³n de que cada parte funciona correctamente tanto individualmente como en conjunto.
        AsegÃºrate de que la funcionalidad implementada coincida con los flujos y estructuras definidas en los archivos JSON de docs/swagger.
            

    Documentar los cambios realizados , incluyendo: 
        ExplicaciÃ³n de quÃ© partes se corrigieron y por quÃ©.
        Instrucciones claras para instalar, configurar y ejecutar el proyecto tras la refactorizaciÃ³n.
        Recomendaciones futuras si fuera necesario.
            
        

Al finalizar, entrega el proyecto completamente funcional, probado y listo para ejecutarse localmente sin errores, con una interfaz limpia, segura y alineada a los estÃ¡ndares actuales." 



Eres un ingeniero full-stack especializado en desarrollo web con Python, Django, frameworks de frontend (React/Vue/Angular) y consumo de APIs externas.
Tu tarea es crear un sistema bancario completo que cumpla con los siguientes requisitos: 
ğŸ§  Requisitos del Sistema 
1. Backend â€“ Django  

    Usar Django puro  (sin Django REST Framework, si se requiere).
    AutenticaciÃ³n de usuarios (login/logout/registro).
    GestiÃ³n de cuentas, transferencias y logs.
    Base de datos local (SQLite o PostgreSQL).
    Endpoints para el frontend (HTML/JS o API segÃºn sea necesario).
     

2. Frontend â€“ Framework  

    Usar React , Vue.js  o Angular  como framework principal.
    Interfaz intuitiva para:
        Iniciar sesiÃ³n.
        Ver saldo.
        Realizar transferencias.
        Ver historial de transacciones.
        Recibir anÃ¡lisis inteligente de operaciones con GPT-4.
         
    Mostrar grÃ¡ficos interactivos con Chart.js o D3.js.
    Soporte para notificaciones en tiempo real (si aplica).
     

3. IntegraciÃ³n con APIs Externas  

    OpenAI GPT-4 : Analizar cada transferencia y mostrar explicaciÃ³n del comportamiento de la operaciÃ³n.
    Telegram Bot API : Enviar notificaciÃ³n automÃ¡tica tras cada transferencia con detalles y QR escaneado.
    Google Authenticator (TOTP) : Validar OTP antes de realizar transferencias sensibles.
     

4. Dashboard de Administrador  

    Solo accesible por usuarios con rol admin .
    Muestra:
        GrÃ¡ficos de transferencias diarias, montos por usuario, distribuciÃ³n geogrÃ¡fica.
        Logs completos de todas las acciones realizadas.
        Usuarios activos y sesiones activas.
         
    Filtros por fecha, tipo de cuenta, monto, etc.
     

5. Seguridad  

    JWT o token-based authentication entre frontend y backend.
    Refresco automÃ¡tico de tokens expirados.
    AuditorÃ­a de acciones: quiÃ©n hizo quÃ©, cuÃ¡ndo y desde quÃ© IP.
    Roles de usuario: usuario, admin.
     

6. Logs AutomÃ¡ticos  

    Guardar en base de datos:
        Fecha/hora.
        Usuario.
        AcciÃ³n realizada.
        Detalles adicionales (monto, destino, resultado).
        IP del cliente.
         
     
ğŸ“ Estructura Sugerida del Proyecto 
banco-sistema/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ manage.py
â”‚   â”œâ”€â”€ banco/
â”‚   â”‚   â”œâ”€â”€ settings.py
â”‚   â”‚   â”œâ”€â”€ urls.py
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ usuarios/
â”‚   â”‚   â”œâ”€â”€ models.py
â”‚   â”‚   â”œâ”€â”€ views.py
â”‚   â”‚   â””â”€â”€ templates/
â”‚   â”œâ”€â”€ transferencias/
â”‚   â”‚   â”œâ”€â”€ models.py
â”‚   â”‚   â”œâ”€â”€ views.py
â”‚   â”‚   â””â”€â”€ templates/
â”‚   â”œâ”€â”€ static/
â”‚   â””â”€â”€ templates/
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ public/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ App.js
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ Login.jsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Dashboard.jsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Transferencia.jsx
â”‚   â”‚   â”‚   â””â”€â”€ Historial.jsx
â”‚   â”‚   â””â”€â”€ services/
â”‚   â”‚       â”œâ”€â”€ auth.service.js
â”‚   â”‚       â”œâ”€â”€ transferencia.service.js
â”‚   â”‚       â””â”€â”€ gpt.service.js
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ ...
â”œâ”€â”€ docker-compose.yml (opcional)
â””â”€â”€ README.md

ğŸ”Œ APIs Externas a Consumir 
Servicio,Funcionalidad
Telegram Bot API,Notificar transferencias con mensajes personalizados y adjuntar imÃ¡genes (QR).
OpenAI API (GPT-4),Analizar cada transferencia y generar una descripciÃ³n inteligente.
Google Authenticator (TOTP),Generar y validar cÃ³digos OTP en el backend.

profile
Qwen3-235B-A22B

Â¡Perfecto! Entiendo que tu sistema bancario ahora debe incluir : 

    âœ… Uso de APIs externas  (como Telegram, OpenAI GPT-4).
    âœ… Uso de un framework para frontend  (por ejemplo: React, Vue.js o Angular).
     

Tu objetivo es tener una aplicaciÃ³n completa con: 

    Backend en Django (sin REST Framework si lo deseas).
    Frontend moderno usando un framework.
    IntegraciÃ³n con APIs externas.
    Seguridad, autenticaciÃ³n y dashboard funcional.
     

âœ… Prompt Optimizado â€“ Sistema Bancario con Django + API Externa + Framework Frontend 

    Prompt:  
     

Eres un ingeniero full-stack especializado en desarrollo web con Python, Django, frameworks de frontend (React/Vue/Angular) y consumo de APIs externas.
Tu tarea es crear un sistema bancario completo que cumpla con los siguientes requisitos: 
ğŸ§  Requisitos del Sistema 
1. Backend â€“ Django  

    Usar Django puro  (sin Django REST Framework, si se requiere).
    AutenticaciÃ³n de usuarios (login/logout/registro).
    GestiÃ³n de cuentas, transferencias y logs.
    Base de datos local (SQLite o PostgreSQL).
    Endpoints para el frontend (HTML/JS o API segÃºn sea necesario).
     

2. Frontend â€“ Framework  

    Dashboard & Simulador 

        Python 3.8+
        LibrerÃ­as: Flask, requests, qrcode, zxingcpp, pillow, python-telegram-bot, openai, matplotlib, pandas
     
     

3. IntegraciÃ³n con APIs Externas  

    OpenAI GPT-4 : Analizar cada transferencia y mostrar explicaciÃ³n del comportamiento de la operaciÃ³n.
    Telegram Bot API : Enviar notificaciÃ³n automÃ¡tica tras cada transferencia con detalles y QR escaneado.
    Google Authenticator (TOTP) : Validar OTP antes de realizar transferencias sensibles.
     

4. Dashboard de Administrador  

    Solo accesible por usuarios con rol admin .
    Muestra:
        GrÃ¡ficos de transferencias diarias, montos por usuario, distribuciÃ³n geogrÃ¡fica.
        Logs completos de todas las acciones realizadas.
        Usuarios activos y sesiones activas.
         
    Filtros por fecha, tipo de cuenta, monto, etc.
     

5. Seguridad  

    JWT o token-based authentication entre frontend y backend.
    Refresco automÃ¡tico de tokens expirados.
    AuditorÃ­a de acciones: quiÃ©n hizo quÃ©, cuÃ¡ndo y desde quÃ© IP.
    Roles de usuario: usuario, admin.
     

6. Logs AutomÃ¡ticos  

    Guardar en base de datos:
        Fecha/hora.
        Usuario.
        AcciÃ³n realizada.
        Detalles adicionales (monto, destino, resultado).
        IP del cliente.
         
     

ğŸ“ Estructura Sugerida del Proyecto 
 
simulador_banco/
â”‚
â”œâ”€â”€ backend/                          # API Spring Boot (Java)
â”‚   â”œâ”€â”€ pom.xml                       # Archivo Maven
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main/
â”‚   â”‚   â”‚   â”œâ”€â”€ java/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ com.markmur.banco/
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ controller/
â”‚   â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ AuthController.java
â”‚   â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ TransferenciaController.java
â”‚   â”‚   â”‚   â”‚       â”‚   â””â”€â”€ LogController.java
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ service/
â”‚   â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ JwtService.java
â”‚   â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ OtpService.java
â”‚   â”‚   â”‚   â”‚       â”‚   â””â”€â”€ TelegramService.java
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ model/
â”‚   â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ Usuario.java
â”‚   â”‚   â”‚   â”‚       â”‚   â””â”€â”€ Log.java
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ BancoApplication.java
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ SecurityConfig.java
â”‚   â”‚   â”‚   â””â”€â”€ resources/
â”‚   â”‚   â”‚       â”œâ”€â”€ application.properties
â”‚   â”‚   â”‚       â””â”€â”€ data.sql          # Datos iniciales
â”‚   â”‚   â””â”€â”€ test/                     # Tests unitarios (opcional)
â”‚   â””â”€â”€ mvnw                          # Script de ejecuciÃ³n Maven
â”‚
â”œâ”€â”€ dashboard/                        # Dashboard Flask + HTML
â”‚   â”œâ”€â”€ app.py                        # Servidor Flask
â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â””â”€â”€ dashboard.html            # PÃ¡gina principal con grÃ¡ficos
â”‚   â”œâ”€â”€ static/
â”‚   â”‚   â””â”€â”€ style.css                 # Estilos CSS
â”‚   â””â”€â”€ requirements.txt              # Requisitos Python
â”‚
â”œâ”€â”€ simulador/                        # Simulador Tkinter
â”‚   â”œâ”€â”€ app.py                        # GUI con Tkinter
â”‚   â”œâ”€â”€ config.py                     # ConfiguraciÃ³n
â”‚   â””â”€â”€ qr_scanner.py                 # EscÃ¡ner de QR
â”‚
â”œâ”€â”€ logs/                             # Logs automÃ¡ticos
â”‚   â””â”€â”€ banco_logs.log                # Registro de operaciones
â”‚
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ start_all.sh                  # Iniciar todo desde terminal
â”‚   â”œâ”€â”€ start_api.sh                  # Solo iniciar API
â”‚   â””â”€â”€ start_dashboard.sh            # Solo iniciar dashboard
â”‚
â””â”€â”€ README.md                         # GuÃ­a rÃ¡pida de instalaciÃ³n y uso
 
âœ… Funcionalidades Incluidas 
MÃ³dulo,CaracterÃ­sticas
ğŸ” AutenticaciÃ³n JWT,"Login, Refresh Token, expiraciÃ³n automÃ¡tica"
ğŸ“± Google Authenticator OTP,GeneraciÃ³n de QR y validaciÃ³n TOTP
ğŸ“Š Dashboard Web,GrÃ¡ficos interactivos de transferencias
ğŸ“‹ AuditorÃ­a,Registros completos de acciones por usuario
ğŸ§  AnÃ¡lisis GPT-4,AnÃ¡lisis inteligente de transacciones sospechosas
ğŸ“¬ Notificaciones por Telegram,Enviar mensajes y adjuntar imÃ¡genes
ğŸ“ Logs AutomÃ¡ticos,Registro detallado de todas las operaciones
ğŸ–¥ï¸ Simulador Tkinter,GUI sencilla con soporte de escaneo de QR
 
ğŸ”Œ APIs Externas a Consumir 
Telegram Bot API
	
Notificar transferencias con mensajes personalizados y adjuntar imÃ¡genes (QR).
OpenAI API (GPT-4)
	
Analizar cada transferencia y generar una descripciÃ³n inteligente.
Google Authenticator (TOTP)
	
Generar y validar cÃ³digos OTP en el backend.
 
 
ğŸ’» Flujo de Uso del Sistema 

    El usuario entra a /login â†’ introduce credenciales.
    Si es vÃ¡lido, inicia sesiÃ³n y accede al dashboard.
    Puede ver su saldo, historial y hacer transferencias.
    Al hacer una transferencia sensible, se genera un cÃ³digo OTP.
    Se muestra un QR que puede escanearse con Google Authenticator.
    Se ingresa el cÃ³digo OTP y se valida.
    Se realiza la transferencia y se envÃ­a notificaciÃ³n por Telegram.
    Se analiza la operaciÃ³n con GPT-4 â†’ resultado mostrado al usuario.
    Todos los pasos quedan registrados en logs.

ğŸ“¦ LibrerÃ­as Necesarias 
Backend (Django)
pip install django qrcode google-auth python-telegram-bot openai python-jose[cryptography] bcrypt

ğŸ¨ base.html â€“ Plantilla Principal 
UbicaciÃ³n: templates/base.html 
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>{% block title %}Banco Seguro{% endblock %}</title>
    <link rel="stylesheet" href="{% static 'css/style.css' %}">
    <script src="{% static 'js/chart.min.js' %}"></script>
</head>
<body>
    <header>
        <h1>ğŸ¦ Banco Seguro</h1>
        {% if user.is_authenticated %}
            <nav>
                <a href="{% url 'dashboard' %}">Dashboard</a>
                <a href="{% url 'transferir' %}">Transferir</a>
                <a href="{% url 'logout' %}">Cerrar SesiÃ³n</a>
            </nav>
        {% endif %}
    </header>

    <main>
        {% block content %}
        {% endblock %}
    </main>

    <footer>
        <p>&copy; 2025 Banco Seguro. Todos los derechos reservados.</p>
    </footer>
</body>
</html>

ğŸ” Vista de Login (usuarios/views.py) 
from django.shortcuts import render, redirect
from django.contrib.auth import login, logout
from django.http import HttpResponse
import requests
import jwt
from datetime import datetime

def login_view(request):
    if request.method == "POST":
        username = request.POST.get("username")
        password = request.POST.get("password")

        # Simular llamada a la API
        response = requests.post("http://localhost:8080/usuarios/login", json={"username": username, "password": password})
        if response.status_code == 200:
            data = response.json()
            token = data["access_token"]
            payload = jwt.decode(token, options={"verify_signature": False})

            request.session["token"] = token
            request.session["refresh_token"] = data["refresh_token"]
            request.session["usuario"] = payload["sub"]

            return redirect("dashboard")

    return render(request, "usuarios/login.html")

ğŸ“Š Dashboard (usuarios/views.py) 
from django.shortcuts import render
from django.http import JsonResponse
import requests

def dashboard_view(request):
    token = request.session.get("token")
    if not token:
        return redirect("login")

    headers = {"Authorization": f"Bearer {token}"}
    response = requests.get("http://localhost:8080/transferencias/historial", headers=headers)

    transferencias = []
    if response.status_code == 200:
        transferencias = response.json()

    return render(request, "usuarios/dashboard.html", {
        "transferencias": transferencias
    })

ğŸ’¸ Vista de Transferencia (transferencias/views.py) 
from django.shortcuts import render, redirect
from django.http import HttpResponse
import requests

def transferir_view(request):
    token = request.session.get("token")
    if not token:
        return redirect("login")

    if request.method == "POST":
        origen = request.POST.get("origen")
        destino = request.POST.get("destino")
        monto = request.POST.get("monto")

        headers = {"Authorization": f"Bearer {token}"}
        payload = {"origen": origen, "destino": destino, "monto": monto}

        response = requests.post("http://localhost:8080/transferencias", json=payload, headers=headers)

        if response.status_code == 403 and response.json().get("error") == "otp_required":
            return redirect("confirmar_otp")

        return redirect("dashboard")

    return render(request, "transferencias/transferir.html")

ğŸ” ConfirmaciÃ³n OTP (usuarios/views.py) 
def confirmar_otp_view(request):
    if request.method == "POST":
        otp = request.POST.get("otp")
        username = request.session.get("usuario")

        response = requests.post(f"http://localhost:8080/auth/validar-otp?username={username}&code={otp}")
        if response.status_code == 200 and response.json():
            return redirect("dashboard")

    return render(request, "usuarios/confirmar_otp.html")

ğŸ“ˆ GrÃ¡ficos DinÃ¡micos en Template 
usuarios/dashboard.html 
{% extends "base.html" %}
{% block title %}Dashboard{% endblock %}
{% block content %}
<h2>ğŸ“Š Transferencias Recientes</h2>
<ul>
    {% for t in transferencias %}
        <li>{{ t.fecha }} - ${{ t.monto }} â†’ {{ t.destino }}</li>
    {% endfor %}
</ul>

<h2>ğŸ“ˆ GrÃ¡fico de Transferencias</h2>
<canvas id="grafico-transferencias" width="600" height="300"></canvas>
<script>
const ctx = document.getElementById('grafico-transferencias').getContext('2d');
new Chart(ctx, {
    type: 'line',
    data: {
        labels: [{% for t in fechas %}"{{ t }}"{% if not forloop.last %}, {% endif %}{% endfor %}],
        datasets: [{
            label: 'Monto',
            data: [{% for t in montos %}{{ t }}{% if not forloop.last %}, {% endif %}{% endfor %}],
            borderColor: 'blue',
            fill: false
        }]
    },
    options: {
        responsive: true,
        scales: {
            y: { beginAtZero: true }
        }
    }
});
</script>
{% endblock %}

ğŸ“„ AuditorÃ­a de Operaciones 
logs/views.py 
from django.shortcuts import render
import requests

def auditoria_view(request):
    token = request.session.get("token")
    headers = {"Authorization": f"Bearer {token}"}
    response = requests.get("http://localhost:8080/auditoria", headers=headers)

    logs = []
    if response.status_code == 200:
        logs = response.json()

    return render(request, "logs/auditoria.html", {"logs": logs})

ğŸ“² Notificaciones por Telegram 

import requests

def enviar_notificacion_telegram(mensaje, foto_path=None):
    bot_token = "TU_BOT_TELEGRAM"
    chat_id = "TU_CHAT_ID"

    if foto_path:
        url = f"https://api.telegram.org/bot{bot_token}/sendPhoto" 
        with open(foto_path, "rb") as photo:
            files = {'photo': photo}
            data = {'chat_id': chat_id, 'caption': mensaje}
            requests.post(url, data=data, files=files)
    else:
        url = f"https://api.telegram.org/bot{bot_token}/sendMessage" 
        data = {'chat_id': chat_id, 'text': mensaje}
        requests.post(url, data=data)

ğŸ—‚ï¸ Registro de Logs Locales 
logs/models.py 
from django.db import models

class Log(models.Model):
    usuario = models.CharField(max_length=100)
    accion = models.TextField()
    fecha = models.DateTimeField(auto_now_add=True)
    ip = models.CharField(max_length=100)
    detalles = models.TextField(blank=True, null=True)


# ==========================================
Eres un ingeniero de software sÃ©nior especializado en arquitectura, desarrollo y mantenimiento de sistemas escalables. Tu misiÃ³n es revisar completamente el repositorio del proyecto que voy a proporcionarte, con un nivel de detalle absoluto. No debes dejar ningÃºn archivo sin analizar, desde la configuraciÃ³n inicial hasta los archivos de plantillas, scripts de despliegue, rutas, vistas, modelos, formularios, estilos, lÃ³gica de negocio, y cualquier otro componente relevante del sistema.

Tu anÃ¡lisis debe incluir:

1. âœ… RevisiÃ³n completa del Ã¡rbol de directorios:
   - Identificar todas las carpetas y archivos relevantes.
   - Detectar posibles inconsistencias en la organizaciÃ³n del proyecto.
   - Verificar si hay duplicados, archivos innecesarios o mal nombrados.

2. ğŸ” AnÃ¡lisis de consistencia entre modelos, vistas, formularios, URLs y plantillas:
   - Para cada modelo existente:
     - Â¿Tiene un formulario asociado?
     - Â¿Existe una vista (view/controller) correspondiente?
     - Â¿EstÃ¡ mapeada su URL/ruta correctamente?
     - Â¿Posee una plantilla HTML (template) asociada?
     - Si alguno de estos elementos falta, debes generar una versiÃ³n funcional y coherente basada en buenas prÃ¡cticas.
   - Generar automÃ¡ticamente cÃ³digo base para los componentes faltantes, respetando la arquitectura del proyecto y el estilo ya establecido.

3. ğŸ“„ DiseÃ±o de muestra para plantillas faltantes:
   - En caso de que falte una plantilla HTML, genera una interfaz funcional y semÃ¡ntica que permita al usuario interactuar con el modelo correspondiente.
   - Usa Bootstrap u otro framework de diseÃ±o si es parte del stack del proyecto.
   - Incluye campos dinÃ¡micos, mensajes de error, validaciones bÃ¡sicas, y navegaciÃ³n coherente.

4. âš™ï¸ ConfiguraciÃ³n global del proyecto:
   - Analiza los archivos de configuraciÃ³n (settings.py, .env, config.js, etc.).
   - Verifica variables de entorno, bases de datos, middlewares, seguridad, internacionalizaciÃ³n, cachÃ©, etc.
   - Detectar configuraciones potencialmente inseguras o incorrectas.

5. ğŸ“œ Scripts y automatizaciones:
   - Revisa todos los scripts personalizados (manage.py, run.sh, deploy.sh, migrations, seeders, etc.).
   - EvalÃºa si son ejecutables, seguros y cumplen su propÃ³sito.
   - Proponer mejoras o corregir errores detectados.

6. ğŸ—‚ï¸ Estructura de plantillas y simuladores:
   - Si el proyecto incluye un simulador o motor de renderizado, revisa las plantillas utilizadas.
   - AsegÃºrate de que todas las vistas se integren correctamente.
   - Completa o corrige cualquier template usado por el simulador para que sea funcional y visualmente correcto.

7. ğŸ“Š Logs y salida del sistema:
   - Si me proporcionas logs del sistema, Ãºsalos para identificar errores especÃ­ficos o warnings recurrentes.
   - Relaciona esos errores con el cÃ³digo fuente para ofrecer correcciones precisas.

8. ğŸ”„ IntegraciÃ³n y flujo de trabajo:
   - Revisa si hay pruebas unitarias, integraciÃ³n continua, pipelines de CI/CD.
   - PropÃ³n mejoras o implementa aquellas que falten si son relevantes.

9. ğŸ›¡ï¸ Seguridad:
   - Detectar posibles agujeros de seguridad (SQL injection, XSS, CSRF, permisos, etc.).
   - Ofrecer recomendaciones de hardening del proyecto.

10. ğŸ“ˆ Escalabilidad:
    - Evaluar si la arquitectura permite escalar el proyecto.
    - Recomendar patrones de diseÃ±o o refactorizaciones que mejoren el rendimiento futuro.

11. ğŸ“ DocumentaciÃ³n:
    - Revisar si existe documentaciÃ³n interna (README.md, docstrings, comentarios, etc.).
    - Sugerir puntos donde se deberÃ­a mejorar o aÃ±adir documentaciÃ³n.

12. ğŸ’¡ Mejoras sugeridas:
    - DespuÃ©s del anÃ¡lisis completo, ofrece una lista de mejoras tÃ©cnicas, UX/UI, de rendimiento o arquitectÃ³nicas que elevarÃ­an la calidad del proyecto.

Al finalizar, quiero que me entregues:
- Un informe detallado del estado actual del proyecto.
- Una lista de elementos incompletos o inconsistentes.
- CÃ³digo generado automÃ¡ticamente para los componentes faltantes (formularios, vistas, URLs, plantillas).
- Recomendaciones claras y priorizadas.
- Archivos modificados o creados, listos para ser copiados al repositorio.

Todo esto debe estar organizado de forma clara, modular y profesional. Tu objetivo es ayudarme a superar este proyecto 100 mil veces. No quiero solo encontrar errores; quiero que lo transformes en algo excepcional.